---
title : Java内存管理基础
category : [jvm]
tags : [jvm, java-memory-manange]
layout : post
show : 1
keywords: jvm,java memory manange,java内存管理
---

<ul>
    <p class="intro">
        众所周之，Java最强大的地方之一就是其<span class="highlight">自动内存管理机制</span>，也就不需要像<span class="highlight">C/C++</span>语言那样，需要开发人员<span class="highlight">手动进行内存管理</span>，需要时刻关注内存应该<span class="highlight">何时正确地被释放</span>。<span class="highlight">自动内存管理机制</span>将程序员从内存管理的凶险解脱出来，这将大大提升Java开发人员的生产力，但作为Java开发人员，即使不用直接面对<span class="highlight">内存管理</span>，但却应该对<span class="highlight">JVM的内存管理机制</span>有所掌握，对自己的编程能力也会有潜移默化的提升。本文将对JVM内存管理进行一番解读，实现主要是<span class="highlight">HotSpot Virtual Machine(J2SE 1.5)</span>。
    </p>


    <li>
    	<h2>手动内存管理 VS 自动内存管理</h2>
    </li>
    <p class="wrap">
    	<span class="highlight">内存管理</span>的一个主要目标就是<span class="highlight">识别那些分配的对象不再需要</span>，并且<span class="highlight">释放掉其所占用的内存空间</span>，以供后续的内存分配使用。有一些编程语言，如<span class="highlight">C++</span>，开发人员手动管理内存，这将很容易出现很多引起<span class="highlight">程序错误和崩溃</span>的问题，比如<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank"><span class="highlight">悬挂引用</span></a>，<span class="highlight">内存泄漏</span>等，因此开发人员需要花费大量时间来调试和修复。
    </p>
    <p class="wrap">
    	现在大多数现代面向对象编程语言中，已被广泛应用的另一种内存管理方法：<span class="highlight">自动内存管理</span>， 其通过<span class="highlight">垃圾收集器(Garbage Collector)</span>来实现内存管理。只要对象还有被引用，<span class="highlight">垃圾收集器</span>将不会对其进行收集，从而避免了<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank"><span class="highlight">悬挂引用</span></a>问题，一旦对象不再被引用，<span class="highlight">垃圾收集器</span>将会在合适的时候对其进行收集，并释放对应的内存空间，因此避免了<span class="highlight">内存泄漏</span>问题。
    </p>

    <li>
    	<h2>垃圾收集原理</h2>
    </li>
    <p class="wrap">
    	通常<span class="highlight">垃圾收集器</span>总体需要负责三件事情: <span class="highlight">为对象分配内存</span>，<span class="highlight">保证任何被引用的对象仍在内存中</span>，<span class="highlight">清理程序中不可达的对象</span>。当为新对象分配内存时，需要在堆中找出具有<span class="highlight">一定大小且未被使用的内存块</span>，这是一件比较困难的事情，大多数<span class="highlight">动态内存分配算法</span>的主要困难在于<span class="highlight">避免内存碎片化</span>，并且同时需要保证<span class="highlight">内存分配和释放的性能</span>。
    </p>

    <li>
    	<h3>理想的垃圾收集器</h3>
    </li>
    <p class="wrap">
    	<span class="highlight">垃圾收集器</span>必须是<span class="highlight">安全且全面的</span>。也就是说，<span class="highlight">存活对象绝不能被错误释放</span>，并且不允许<span class="highlight">垃圾对象经过多个垃圾收集周期仍然未被释放</span>。
    </p>
    <p class="wrap">
    	<span class="highlight">垃圾收集器</span>也应该能够有效地运行，以至于不应该导致应用暂停太长时间。然而，对于大多数计算机相关的系统，都需要在<span class="highlight">时间</span>，<span class="highlight">空间</span>和频率等因素作出一些权衡。例如，若<span class="highlight">JVM堆</span>设置过小，虽然每次垃圾收集会变得更快，但是总的垃圾收集次数也会更多；若<span class="highlight">JVM堆</span>设置过大，虽然总的垃圾收集次数有所减少，但每次垃圾收集耗时也会更长。
    </p>
    <p class="wrap">
    	<span class="highlight">垃圾收集器</span>也需要针对<span class="highlight">内存碎片</span>作一些处理，在垃圾收集过程中，对一些小对象回收后，有可能会产生很多空间较小的<span class="highlight">内存块</span>，这些小内存块不能容纳下<span class="highlight">大对象</span>，最坏的情况也就是即便内存还未使用完，但却不能再分配对象。<span class="highlight">清理碎片</span>的过程叫<span class="highlight">压缩(Compaction)</span>。
    </p>
    <p class="wrap">
    	另外，<span class="highlight">可扩展性</span>也是相当重要的，在多处理器系统中，对于多线程应用，<span class="highlight">内存分配</span>不应该成为<span class="highlight">可扩展性瓶颈</span>，<span class="highlight">收集操作</span>也不应该成为这样的瓶颈。
    </p>

  	<li>
    	<h3>如何设计或选择垃圾收集器</h3>
    </li>
    <p class="wrap">
    	在设计或选择<span class="highlight">垃圾收集器</span>时，通常需要作出一些选择:
    </p>
	<li>
		<h4>串行 VS 并行</h4>
	</li>  
	<p class="wrap">
		对于<span class="highlight">串行收集</span>，同一时刻只能作一件事，比如，即使有多个CPU可用时，只有其中一个才能用于执行<span class="highlight">垃圾收集</span>。当使用<span class="highlight">并行收集</span>时，<span class="highlight">垃圾收集任务</span>将被分成若干个子任务，并同时在不同的CPU上执行，<span class="highlight">并行执行</span>使得垃圾收集执行得更快，但这也导致了<span class="highlight">额外的复杂度和内存碎片问题</span>。
	</p>
	<li>
		<h4>并发 VS Stop-the-world</h4>
	</li>  
	<p class="wrap">
		当<span class="highlight">stop-the-world</span>垃圾收集正在执行时，整个应用将被挂起，这对于<span class="highlight">强交互应用(要求低暂停时间短)</span>并不友好，比如Web应用。相比<span class="highlight">stop-the-world</span>，有一些垃圾收集器的收集任务可以与应用同时执行。典型的<span class="highlight">并发垃圾收集器</span>会并发执行大部分垃圾工作，但仍然会有短暂的<span class="highlight">stop-the-world</span>。显然，<span class="highlight">Stop-the-world垃圾收集</span>比<span class="highlight">并发垃圾收集</span>更简单，因为在整个收集过程中，JVM堆会被冻结，因而对象的状态将不会发生改变，但缺点也很明显，收集过程<span class="highlight">会挂起应用</span>。相对于使用<span class="highlight">并发垃圾收集器</span>时，<span class="highlight">应用暂停时间</span>将被缩短，但需要额外注意一些细节，<span class="highlight">垃圾收集器</span>在操作对象时，与此同时，有可能应用程序也在操作相同的对象，为了保证<span class="highlight">垃圾收集器</span>不会错误地回收对象，则要增加一些额外影响性能的工作，并且需要更大的堆内存。
	</p>
	<li>
		<h4>压缩 VS 复制</h4>
	</li>  
	<p class="wrap">
		当<span class="highlight">垃圾收集器</span>已经决定哪些对象存活及哪些对象需要回收之后，可以进行<span class="highlight">内存压缩</span>，即将所有存活的对象移动到一起(连续)，然后完全释放掉需要回收的内存。<span class="highlight">内存压缩</span>之后，就能够很容易且很快地将新对象分配在第一块空间内存中了，一个简单的指针就能跟踪下一个内存分配的位置。与<span class="highlight">内存压缩型收集器</span>相比，<span class="highlight">非内存压缩收集器</span>则利用额外的内存空间来回收垃圾对象，即不会像<span class="highlight">内存压缩型收集器</span>一样将所有存活对象移动一起，以便释放出一大块空闲内存，这样的好处是<span class="highlight">垃圾收集</span>时间更短，缺点则是潜在的<span class="highlight">内存碎片问题</span>。通常来说，从堆中分配对象比压缩堆更昂贵，因为为了分配新对象，可能有必要在堆中寻找<span class="highlight">一段足够大的连续空间</span>。第三个可选的则是<span class="highlight">复制收集器</span>，即复制存活的对象到另一个内存区，这样的好处是保持<span class="highlight">源内存区</span>是空闲的，可以很容易且很快地用于后续的对象分配，但缺点是需要<span class="highlight">额外的时间来执行复制操作</span>和<span class="highlight">额外的内存空间</span>。
	</p>

	<li>
    	<h3>性能指标</h3>
    </li>
    <p class="wrap">
    	通常会使用几个指标来评估一个<span class="highlight">垃圾收集器</span>的性能，包括：
    </p>
    <table class="ui celled teal small table">
    	<thead>
    		<tr>
    			<th>指标类型</th>
    			<th>描述</th>
    		</tr>
    	</thead>
    	<tbody>
    		<tr>
    			<td>
    				<span class="highlight">吞吐量</span>
				</td>	
    			<td>
    				应用程序执行时间 / (应用程序执行时间 + 垃圾收集执行时间)
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">垃圾收集开销</span>
				</td>	
    			<td>
    				垃圾收集执行时间 / (应用程序执行时间 + 垃圾收集执行时间)
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">停顿时间</span>
				</td>	
    			<td>
    				当垃圾收集正在执行时，<span class="highlight">应用程序被挂起的总时间</span>。
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">垃圾收集频率</span>
				</td>	
    			<td>
    				相对于应用程序，<span class="highlight">垃圾收集多久发生一次</span>。
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">占用空间</span>
				</td>	
    			<td>
    				垃圾收集所占用的<span class="highlight">内存大小</span>
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">及时性</span>
				</td>	
    			<td>
    				一个对象从被标记为<span class="highlight">垃圾对象</span>到该对象所占空间变得可用的时间
				</td>	
    		</tr>
    	</tbody>
	</table>
	<p class="wrap">
		对于<span class="highlight">交互式应用</span>，可能要求更低的<span class="highlight">停顿时间</span>，然而对于<span class="highlight">非交互式应用</span>，<span class="highlight">总执行时间</span>显得更重要。一个<span class="highlight">实时应用程序</span>将要求在<span class="highlight">暂停时间</span>和<span class="highlight">垃圾收集占用时间</span>都具有较小的值。<span class="highlight">占用较少空间</span>则可能是一些小的个人电脑或嵌入式系统所关心的主要问题。
	</p>

	<li>
		<h3>分代回收</h3>
	</li>
	<p class="wrap">
		当使用<span class="highlight">分代回收</span>时，JVM堆将被分为不同的<span class="highlight">分代</span>(容纳不同年龄的对象)。比如，最广泛使用的分代有：<span class="highlight">年轻对象</span>和<span class="highlight">老对象</span>。
	</p>
	<p class="wrap">
		在不同分代上，可以使用不同的算法执行垃圾回收，每种算法会针对不同的分代作特定优化，之所以采用<span class="highlight">分代垃圾回收</span>，主要利用了以下特性(称作<span class="highlight">弱代假设</span>):
	</p>
	<div class="ui bulleted list">
    	<div class="item">
    		大多数对象不会被长期引用，即<span class="highlight">存活时间短</span>。
    	</div>
    	<div class="item">
    		很少有<span class="highlight">老对象会引用年轻对象</span>。
    	</div>
	</div>
	<p class="wrap">
		<span class="highlight">年轻代回收</span>触发会比较频繁，但执行很快，因为<span class="highlight">年轻代</span>通常<span class="highlight">内存空间较小</span>，且可能包含了<span class="highlight">大量不再被引用的对象</span>。而经过几次<span class="highlight">年轻代回收</span>存活下来的对象，将晋升到<span class="highlight">老年代</span>。<span class="highlight">老年代</span>通常比<span class="highlight">年轻代</span>大很多，其内存占用率会<span class="highlight">慢慢增加</span>，因此<span class="highlight">触发不会很频繁</span>，但每次<span class="highlight">耗时会比较长</span>，如图:
	</p>
	<img src="{{sitel.url}}/images/jvm/generational-gc.png" width="50%">
	<p class="wrap">
		由于<span class="highlight">年轻代回收</span>触发相对频繁，因此<span class="highlight">年轻代</span>更倾向于使用<span class="highlight">收集速度快</span>的算法。而<span class="highlight">老年代</span>通常使用<span class="highlight">空间高效</span>的收集算法，因为<span class="highlight">老年代</span>占用了整个JVM堆的大部分，并且<span class="highlight">老年代收集算法</span>还能较好地处理<span class="highlight">内存碎片</span>问题。
	</p>

	<li>
		<h2>HotSpot JVM中的垃圾收集器</h2>
	</li>
	<p class="wrap">
		<span class="highlight">HotSpot JVM</span>中包含了四个垃圾收集器，这些收集器都是分代的，下面将一一介绍。
	</p>
	<li>
		<h3>
			HotSpot分代
		</h3>
	</li>
	<p class="wrap">
		在<span class="highlight">HotSpot JVM</span>中堆被分为了三个代：
	</p>
	<table class="ui celled teal small table">
    	<thead>
    		<tr>
    			<th>分代类型</th>
    			<th>描述</th>
    		</tr>
    	</thead>
    	<tbody>
    		<tr>
    			<td>
    				<span class="highlight">年轻代</span>
				</td>	
    			<td>
    				大多数新对象将被分配在<span class="highlight">年轻代</span>上。
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">老年代</span>
				</td>	
    			<td>
    				经过若干次<span class="highlight">年轻代垃圾回收</span>存活下来的对象会晋升到<span class="highlight">老年代</span>，或者有些大对象会直接分配到<span class="highlight">老年代</span>上。
				</td>	
    		</tr>
    		<tr>
    			<td>
    				<span class="highlight">永久代</span>
				</td>	
    			<td>
    				存放一些类或方法等元数据。
				</td>	
    		</tr>
    	</tbody>
	</table>
	<p class="wrap">
		<span class="highlight">年轻代</span>由1个<span class="highlight">Eden区</span>和2个<span class="highlight">Survivor区</span>组成，如下图。大多数新对象会首先被分配在<span class="highlight">Eden区</span>(但某些大对象会直接分配到<span class="highlight">老年代</span>)，<span class="highlight">Survivor区</span>用于存放至少经历过一次<span class="highlight">年轻代收集</span>的对象，这些对象在被晋升到<span class="highlight">老年代</span>之前，也可能被收集，这些对象将存放在其中一个<span class="highlight">Survivor区</span>(<span class="highlight">From区</span>)中，另一个<span class="highlight">Survivor区</span>(<span class="highlight">To区</span>)直到下一次收集前将保持为<span class="highlight">清空状态</span>。
	</p>
	<img src="{{site.url}}/images/jvm/young-generation.png" width="50%">

	<li>
		<h3>
			垃圾收集类型
		</h3>
	</li>
	<p class="wrap">
		当<span class="highlight">年轻代</span>被填充满后，会触发<span class="highlight">年轻代垃圾回收</span>(也称为<span class="highlight">Minor GC</span>)。当<span class="highlight">老年代</span>或<span class="highlight">永久代</span>填充满后，会触发<span class="highlight">完全垃圾回收</span>(也称为<span class="highlight">Major GC</span>)，这时所有代都会执行<span class="highlight">垃圾回收</span>，如果<span class="highlight">内存压缩</span>被触发，将在不同代上单独执行。
	</p>
	<p class="wrap">
		有时，由于<span class="highlight">老年代</span>太满而不能接受来自<span class="highlight">年轻代</span>晋升的老对象，这种情况下，<span class="highlight">老年代垃圾收集算法</span>将在整个<span class="highlight">JVM堆</span>上执行(<span class="highlight">年轻代收集算法不会执行</span>)。(除了当<span class="highlight">老年代</span>使用<span class="highlight">CMS垃圾收集器</span>时，因为<span class="highlight">CMS垃圾收集器</span>不能收集<span class="highlight">年轻代</span>)。
	</p>

	<li>
		<h3>快速分配</h3>
	</li>
	<p class="wrap">
		从下文对垃圾收集器的描述中可以看出，在多数情况下，内存中都有大块的连续空闲空间用以分配新对象。这种情形下使用简单的<span class="highlight">bump-the-pointer</span>技术，将使得分配操作效率很高。按照这种技术，JVM内部维护一个指针<span class="highlight">allocatedTail</span>，它始终指向先前已分配对象的尾部，当新对象分配请求到来时，只需检查代中剩余空间是否足以容纳该对象，若成功分配对象，则会更新<span class="highlight">allocatedTail指针</span>，并初始化对象。
	</p>
	<p class="wrap">
		对于<span class="highlight">多线程应用</span>，对象分配操作必须保证<span class="highlight">线程安全</span>。如果使用<span class="highlight">全局锁</span>来保证<span class="highlight">线程安全</span>，<span class="highlight">内存分配</span>势必成为瓶颈并降低性能。<span class="highlight">HotSpot JVM</span>内部使用了<span class="highlight">Thread-Local Allocation Buffers (TLABs)</span>技术来提升<span class="highlight">多线程内存分配的吞吐量</span>。<span class="highlight">TLAB</span>作为<span class="highlight">线程私有</span>的内存区，分配新对象时不需要额外加锁，使得分配操作很快。偶尔当线程填充满了<span class="highlight">TLAB</span>后，JVM会重新分配一个<span class="highlight">TLAB</span>，此时则必须使用<span class="highlight">同步</span>。同时，为了减少<span class="highlight">TLAB</span>所带来的空间消耗，还使用了一些其他技术，例如，分配器能够把<span class="highlight">TLAB</span>的平均大小限制在<span class="highlight">Eden区</span>的1％以下。通过组合使用<span class="highlight">TLAB</span>和<span class="highlight">bump-the-pointer</span>线性分配技术，就使得一次内存分配足够高效，仅10条机器指令。
	</p>

	<li>
		<h3 id="serial-gc">
			串行收集器(Serial Collector)
		</h3>
	</li>
	<p class="wrap">
		使用<span class="highlight">串行收集器</span>时，<span class="highlight">年轻代收集</span>和<span class="highlight">老年代收集</span>都以<span class="highlight">stop-the-world</span>方式串行执行(单个CPU)，收集过程中应用程序将被挂起。
	</p>
	<li>
		<h4>
			年轻代使用串行收集器
		</h4>
	</li>
	<p class="wrap">
		下面以图展示<span class="highlight">年轻代</span>使用<span class="highlight">串行收集器</span>时发生<span class="highlight">GC</span>的过程:
	</p>
	<div class="ui bulleted list">
    	<div class="item">
    		在<span class="highlight">Eden区</span>未填满时，并未发生GC，两个<span class="highlight">Survivor区</span>和<span class="highlight">老年代</span>均为空:    		
    	</div>
    	<img src="{{site.url}}/images/jvm/young-gc-1.png" width="60%">
    	<div class="item">
    		当<span class="highlight">Eden区</span>逐渐消耗内存，已没有足够内存容纳新对象时，则触发一次<span class="highlight">Minor GC</span>，在<span class="highlight">Eden区</span>标记出<span class="highlight">存活对象</span>和<span class="highlight">垃圾对象</span>，然后将<span class="highlight">存活对象</span>复制到<span class="highlight">Survivor From区</span>，并将存活对象的<span class="highlight">生存年龄+1</span>，最后清空<span class="highlight">Eden区</span>:
    	</div>
    	<img src="{{site.url}}/images/jvm/young-gc-2.png" width="60%">
    	<img src="{{site.url}}/images/jvm/young-gc-2-1.png" width="60%">
    	<div class="item">
    		<span class="highlight">Eden区</span>继续分配新对象，直到再一次内存不足，触发<span class="highlight">Minor GC</span>，在<span class="highlight">Eden区</span>和<span class="highlight">Survivor From区</span>标记出<span class="highlight">存活对象</span>和<span class="highlight">垃圾对象</span>，然后将<span class="highlight">存活对象</span>复制到<span class="highlight">Survivor To区</span>，并将存活对象的<span class="highlight">生存年龄+1</span>，最后清空<span class="highlight">Eden区</span>和<span class="highlight">Survivor From区</span>，并将<span class="highlight">Survivor From区</span>和<span class="highlight">Survivor To区</span>置换:
    	</div>
    	<img src="{{site.url}}/images/jvm/young-gc-3.png" width="60%">
    	<img src="{{site.url}}/images/jvm/young-gc-3-1.png" width="60%">
    	<div class="item">
    		在不断的<span class="highlight">Minor GC</span>后，<span class="highlight">存活对象</span>的生存年龄逐渐增加至<span class="highlight">晋升年龄阈值</span>(可通过<span class="highlight">-XX:MaxTenuringThreshold=n</span>设置)时，<span class="highlight">存活对象</span>将晋升到<span class="highlight">老年代</span>:
    	</div>
    	<img src="{{site.url}}/images/jvm/young-gc-4.png" width="60%">
    	<div class="item">
    		除了上述这种<span class="highlight">正常的老对象晋升</span>情况外，其他一些情况也可能将存活对象晋升到<span class="highlight">老年代</span>，如当<span class="highlight">Survivor To区</span>空间不足已容纳存活对象时(可通过<span class="highlight">–XX:TargetSurvivorRatio</span>设置<span class="highlight">Survivor区可使用率</span>，当存放的对象超过这个百分比时，则对象会向晋升到<span class="highlight">老年代</span>)，存活对象将直接复制到<span class="highlight">老年代</span>(即使存活对象年龄没有达到<span class="highlight">晋升年龄阈值</span>)，又如当分配的新对象太大(可通过<span class="highlight">-XX:PetenureSizeThreshold</span>设置大对象阈值，当对象的大小超过这个值时，将直接在年老代分配，该参数只对<span class="highlight">串行收集器</span>和<span class="highlight">年轻代并行收集器</span>有效，<span class="highlight">并行回收收集器</span>不识别这个参数)，导致<span class="highlight">Eden区</span>不能容下，也会直接晋升到<span class="highlight">老年代</span>:
    	</div>
    	<img src="{{site.url}}/images/jvm/young-gc-5-1.png" width="60%">
    	<img src="{{site.url}}/images/jvm/young-gc-5-2.png" width="60%">
	</div>
	<li>
		<h4>
			老年代使用串行收集器
		</h4>
	</li>
	<p class="wrap">
		当使用<span class="highlight">串行收集器</span>时，<span class="highlight">老年代</span>和<span class="highlight">永久代</span>使用<span class="highlight">标记-清除-压缩(Mark-Sweep-Compact)</span>算法执行垃圾回收。在<span class="highlight">标记阶段</span>，收集器标识出<span class="highlight">存活对象</span>。在<span class="highlight">清除阶段</span>，收集器标识出<span class="highlight">垃圾对象</span>。然后，收集器执行<span class="highlight">滑动压缩</span>过程，将<span class="highlight">存活对象</span>移到<span class="highlight">老年代</span>起始端(<span class="highlight">永久代</span>亦如此)，然后留出一块连续的内存块，这样后续就能在<span class="highlight">老年代</span>或<span class="highlight">永久代</span>使用<span class="highlight">bump-the-pointer</span>技术，加快内存分配:
	</p>
	<img src="{{site.url}}/images/jvm/old-gc-mark-sweep-compact.png" width="60%">
	<li>
		<h4>
			何时使用串行收集器?
		</h4>
	</li>
	<p class="wrap">
		对于大多数运行在客户端模式的应用，并不要求<span class="highlight">低暂停时间</span>，因此可以使用<span class="highlight">串行收集器</span>可作为垃圾收集器。按照现今的硬件水平，<span class="highlight">串行收集器</span>可以高效地管理许多使用64MB堆空间、最长停顿时间不能超过半秒的重要应用。
	</p>
	<li>
		<h4 id="parallel-gc">
			选择串行收集器
		</h4>
	</li>
	<p class="wrap">
		在J2SE 5.0版本中，对于<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html" target="_blank">非服务器级机器</a>而言，<span class="highlight">串行收集器</span>作为默认的垃圾收集器；对于其他硬件平台，则可以通过命令行选项<span class="highlight">-XX:+UseSerialGC</span>进行显示的选用。
	</p>

	<!-- 并行收集器 -->

	<li>
		<h3 id="paralle-gc">
			并行收集器(Parallel Collector)
		</h3>
	</li>
	<p class="wrap">
		目前，许多Java应用都运行在大都包含很大物理内存和多个CPU的平台上。<span class="highlight">并行收集器</span>，也被称作<span class="highlight">吞吐量收集器</span>，被开发出来的主要目的就是为了充分利用CPU资源，而不是只让一个CPU去<span class="highlight">执行垃圾收集</span>，而其他CPU却空闲着。
	</p>
	<li>
		<h4>
			年轻代使用并行收集器
		</h4>
	</li>
	<p class="wrap">
		<span class="wrap">并行收集器</span>作为<span class="wrap">串行收集器</span>的并行版本实现，但仍然是一个<span class="highlight">stop-the-world</span>和<span class="highlight">复制</span>收集器，只不过利用了多个CPU，并行执行<span class="highlight">年轻代回收</span>，这样就减少了<span class="highlight">垃圾回收占用时间</span>，从而<span class="highlight">提高了应用吞吐量</span>，如图所示:
	</p>
	<img src="{{sitel.url}}/images/jvm/young-serial-vs-paralle.png" width="60%">
	<li>
		<h4>
			老年代使用并行收集器
		</h4>
	</li>
	<p class="wrap">
		<span class="highlight">并行收集器</span>对<span class="highlight">老年代</span>使用的垃圾收集算法和<span class="highlight">串行收集器</span>一样，使用的是<span class="highlight">标记-清除-压缩(Mark-Sweep-Compact)</span>算法。
	</p>
	<li>
		<h4>
			何时使用并行收集器
		</h4>
	</li>
	<p class="wrap">
		能够受益于<span class="highlight">并行收集器</span>的应用程序，必定运行在多CPU机器上，并且对停顿时间不能有特别要求，因为持续时间较长的<span class="highlight">老年代收集</span>还是会偶尔会发生。适于采用<span class="highlight">并行收集器</span>的典型应用包括<span class="highlight">批处理</span>、<span class="highlight">记帐</span>、<span class="highlight">工资单</span>和<span class="highlight">科学计算</span>等。你可能更倾向于选择<a href="#paralle-compact-gc">并行压缩收集器(Parallel Compacting Collector)</a>(见下文)而不是<span class="highlight">并行收集器</span>，因为<span class="highlight">并行压缩收集器</span>对所有代(而不只是<span class="highlight">年轻代</span>)的收集都采用<span class="highlight">并行方式</span>进行。
	</p>
	<li>
		<h4>
			选择并行收集器
		</h4>
	</li>
	<p class="wrap">
		在J2SE 5.0版本中，对于<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html" target="_blank">服务器级硬件</a>而言，将使用<span class="highlight">并行收集器</span>作为默认的垃圾收集器；对于其他硬件平台，则可以通过命令行选项<span class="highlight">-XX:+UseParallelGC</span>进行显示的选用。
	</p>

	<!-- 并行压缩收集器 -->

	<li>
		<h3 id="paralle-compact-gc">
			并行压缩收集器(Parallel Compacting Collector)
		</h3>
	</li>
	<p class="wrap">
		<span class="highlight">并行压缩收集器</span>在J2SE 5.0 Update 6中引入，与<a href="#paralle-gc">并行收集器</a>的区别在于，其对<span class="highlight">老年代</span>的收集它使用了全新的算法(<span class="highlight">并行压缩收集器终将取代并行收集器</span>)。
	</p>
	<li>
		<h4>
			年轻代使用并行压缩收集器
		</h4>
	</li>
	<p class="wrap">
		<span class="wrap">年轻代</span>使用<span class="highlight">并行压缩收集器</span>时，收集算法与<span class="highlight">并行收集器</span>时一样。
	</p>
	<li>
		<h4>
			老年代使用并行压缩收集器
		</h4>
	</li>
	<p class="wrap">
		使用<span class="highlight">并行压缩收集器</span>时，对<span class="highlight">老年代</span>和<span class="highlight">永久代</span>将采用<span class="highlight">stop-the-world</span>和<span class="highlight">不完全并行的滑动压缩</span>的方式进行垃圾回收。<span class="highlight">并行压缩收集器</span>会将每个代逻辑上分为大小固定的区域，每个区域的相关信息保存在收集器维护的内部数据结构中，随后会执行三个阶段：<span class="highlight">标记(Marking)</span>，<span class="highlight">汇总(Summary)</span>和<span class="highlight">压缩(Compaction)</span>。
	</p>
	<p class="wrap">
		在<span class="highlight">标记(Marking)阶段</span>，<span class="highlight">根引用集(根存活对象集)</span>被划分给多个<span class="highlight">垃圾收集线程</span>，然后以<span class="highlight">并行</span>的方式对<span class="highlight">存活对象</span>进行<span class="highlight">追踪和标记</span>。在对象被标记为<span class="highlight">存活</span>时，该对象所在区域的数据也将被同步更新，以反映该<span class="highlight">存活对象的大小和位置信息</span>。
	</p>
	<p class="wrap">
		在<span class="highlight">汇总(Summary)阶段</span>，操作不再基于对象，而是<span class="highlight">区域</span>。考虑到之前<span class="highlight">垃圾收集压缩</span>的结果，每个代空间中位于左侧的某一部分通常是比较<span class="highlight">密集的</span>，主要包含了<span class="highlight">存活对象</span>。能从这些密集区块中回收的内存空间已经不多，使得它们并不值得被压缩。因此<span class="highlight">汇总阶段的首要任务</span>就是<span class="highlight">检查区域的密集度</span>，从最左边一个区域开始，直到找到这样的一个区域，<span class="highlight">使得在该区域及其右侧所有区域中可被回收的内存空间抵得上对它们进行压缩的成本</span>，该区域左侧的所有区域就被称为<span class="highlight">密集前置区</span>，没有对象会被移入其中，该区域及其右侧所有区域会被压缩，以<span class="highlight">消除所有死空间</span>。<span class="highlight">汇总阶段</span>的下一个任务就是计算并保存每个<span class="highlight">被压缩区域</span>中存活数据的首字节在压缩后的新位置。需要注意的是：<span class="highlight">汇总阶段在目前被实现为一个串行阶段</span>，这也是<span class="highlight">不完全并行</span>的由来，并行实现也是可能的，只是与<span class="highlight">标记</span>和<span class="highlight">压缩</span>阶段的并行化相比，它对性能的影响不大。
	</p>
	<p class="wrap">
		在<span class="highlight">压缩(Compaction)阶段</span>，<span class="highlight">垃圾收集线程</span>使用<span class="highlight">汇总阶段的数据</span>确定需要被填充的区域，然后它们就可以并行地把对象拷贝到这些区域中，而不再需要额外的同步。这就产生了一个堆，堆空间的一端塞满了<span class="highlight">存活对象</span>，而另一端则是一个<span class="highlight">单一且连续的空闲内存块</span>。
	</p>
	<li>
		<h4>
			何时使用并行压缩收集器
		</h4>
	</li>
	<p class="wrap">
		和<span class="highlight">并行收集器</span>一样，<span class="highlight">并行压缩收集器</span>同样有益于在多CPU机器上运行的应用程序。除此之外，<span class="highlight">老年代收集</span>的并行化操作方式还减少了停顿时间，使得<span class="highlight">并行压缩收集器</span>比<span class="highlight">并行收集器</span>更为适合那些有<span class="highlight">停顿时间限制</span>的应用。不过，对于运行在<span class="highlight">大型共享主机</span>(SunRays)上的应用来说，<span class="highlight">并行压缩收集器</span>也许并不太合适，因为任何单一应用都不应长时间独占几个CPU，在这样的机器上，要么考虑通过命令行选项<span class="highlight">-XX:ParallelGCThreads=n<span class="highlight">减少垃圾收集线程的数目，要么考虑选择一种不同的收集器。
	</p>
	<li>
		<h4>
			选择并行压缩收集器
		</h4>
	</li>
	<p class="wrap">
		<span class="highlight">并行压缩收集器</span>只能通过命令行选项<span class="highlight">-XX:+UseParallelOldGC</span>进行显示的选用。
	</p>


	<li>
		<h3>
			并发-标记-清理收集器(Concurrent Mark-Sweep (CMS) Collector)
		</h3>
	</li>
	<p class="wrap">
		对于许多应用来说，端到端的<span class="highlight">吞吐量</span>并不像<span class="highlight">快速响应时间</span>那么重要。通常来讲，对<span class="highlight">年轻代</span>的收集并不会引起太长时间的停顿。但是对<span class="highlight">老年代</span>的收集，虽然不常发生，却可能导致停顿时间过长的状况，特别在堆空间很大时尤其明显。为了解决这个问题，<span class="highlight">HotSpot JVM</span>提供了一个名叫<span class="highlight">并发-标记-清理(CMS)</span>的收集器，它也被称为<span class="highlight">低延迟收集器</span>。
	</p>
	<li>
		<h4>
			年轻代使用CMS收集器
		</h4>
	</li>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>收集年轻代时，同<a href="#paralle-gc">并行收集器</a>。
	</p>
	<li>
		<h4>
			老年代使用CMS
		</h4>
	</li>
	<p class="wrap">
		采用<span class="highlight">CMS收集器</span>收集老年代时，大部分收集任务与应用程序<span class="highlight">并发执行</span>。
	</p>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>的收集周期开始于<span class="highlight">初始标记(Initial Marking)</span>，它采用<span class="highlight">stop-the-world</span>方式进行，用于确定<span class="highlight">根引用集(根存活对象集)</span>。随后进入<span class="highlight">并发标记(Concurrent Marking)</span>阶段，完成对所有<span class="highlight">存活对象的追踪和标记</span>，以<span class="highlight">并发并行</span>方式进行。由于在<span class="highlight">并发标记过程中</span>应用程序正在执行并可能更新了一些对象的引用，因此并发标记过程结束时并非所有活动对象都已确保被标记出来。为了处理这种情况，应用程序会再次暂停，收集过程进入<span class="highlight">再标记(Remarking)阶段</span>，它采用<span class="highlight">并行、stop-the-world</span>方式进行，通过对<span class="highlight">并发标记过程中被修改对象</span>的再次遍历，最终完成整个标记过程。
	</p>
	<p class="wrap">
		<span class="highlight">再标记(Remarking)阶段</span>完成后，所有<span class="highlight">存活对象</span>都已确保被标记，随后进入<span class="highlight">并发清理阶段</span>，它采用<span class="highlight">串行、并发</span>方式进行，就地回收所有垃圾对象。下图展示了<span class="highlight">串行的标记-清理-压缩收集器</span>和<span class="highlight">CMS收集器</span>在收集<span class="highlight">老年代</span>时的区别：
	</p>
	<img src="{{site.url}}/images/jvm/old-serial-vs-cms.png" width="60%">
	<p class="wrap">
		因为某些任务(例如<span class="highlight">再标记(Remarking)过程中对被修改对象的再次遍历</span>)增加了收集器的工作量，<span class="highlight">CMS收集器</span>的总体开销自然会增大，但对于大多数试图<span class="highlight">减少停顿时间</span>的收集器来说，这是一种典型的折衷方案。
	</p>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>是唯一一个不使用<span class="highlight">内存压缩(Compaction)技术</span>的收集器。也就是说，在垃圾对象所占用的空间被释放以后，收集器并不会把<span class="highlight">存活对象</span>全部整理到代空间的某一端去。见下图：
	</p>
	<img src="{{site.url}}/images/jvm/old-gc-cms-sweep.png" width="60%">
	<p class="wrap">
		这种方式<span class="highlight">节省了回收时间</span>，但却因为空闲空间不再连续，收集器也就不再可能只使用一个<span class="highlight">简单指针</span>即可指示出可分配给新对象的空闲空间位置，相反，它现在需要使用<span class="highlight">空闲空间列表</span>。也就是说，收集器创建并通过一组列表把<span class="highlight">内存中尚未分配的区域</span>连接起来，每当有对象需要分配空间时，通过链表查询到一块足以放下该对象的空闲区域。与使用<span class="highlight">bump-the-pointer技术</span>相比，<span class="highlight">老年代</span>中的分配操作变得更加昂贵。同时这也给<span class="highlight">年轻代收集</span>带来了额外的开销，因为在其收集过程中每<span class="highlight">晋升一个对象</span>都会触发一次<span class="highlight">老年代</span>中的分配操作。
	</p>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>的另一个缺点是<span class="highlight">与其他收集器相比它需要更大的堆空间</span>。一方面，由于在<span class="highlight">标记(Marking)阶段</span>应用程序被允许运行，它就可能继续分配内存，从而可能使<span class="highlight">老年代</span>空间不断地增长，另一方面，虽然<span class="highlight">标记(Marking)阶段</span>完成后所有<span class="highlight">存活对象</span>都已确保被标记，但是在标记过程中一些对象却可能变为<span class="highlight">垃圾对象</span>，而且直到下次<span class="highlight">老年代收集</span>之前它们不会被回收，这样的对象也被称为<span class="highlight">浮动垃圾</span>。
	</p>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>的最后一个缺点是由于<span class="highlight">缺乏压缩</span>，这可能引发<span class="highlight">碎片化问题</span>。为了处理碎片化，<span class="highlight">CMS收集器</span>会跟踪对象的常用大小，评估未来内存分配需求，并为满足需求还可能<span class="highlight">分割或合并空闲内存块</span>。
	</p>
	<p class="wrap">
		不像其他<span class="highlight">垃圾收集器</span>，<span class="highlight">CMS收集器</span>并不是等到<span class="highlight">老年代</span>填满后才启动<span class="highlight">老年代收集</span>，而是尝试尽早启动<span class="highlight">老年代收集</span>，以便在<span class="highlight">老年代</span>被填满之前收集过程可以完成。否则的话，<span class="highlight">CMS收集器</span>将采用在<span class="highlight">串行和并行收集器</span>中使用的<span class="highlight">标记－清理－压缩算法</span>(尽管该算法也使用<span class="highlight">stop-the-world</span>方式)，这将更耗时。为避免这种情况的发生，<span class="highlight">CMS收集器</span>对之前<span class="highlight">收集所耗时间和代空间填满所耗时间</span>进行统计，并据此统计信息<span class="highlight">确定收集启动时间</span>。另外，当<span class="highlight">老年代</span>的空间占用率超过<span class="highlight">启动占用率(initiating occupancy)</span>时，<span class="highlight">CMS收集器</span>也将启动一次收集。启动占用率的值可以通过命令行选项<span class="highlight">-XX:CMSInitiatingOccupancyFraction=n</span>进行设定，其中n表示年长代空间大小的百分比。缺省值为68。
	</p>
	<p class="wrap">
		总体来说，与<span class="highlight">并行收集器</span>相比，<span class="highlight">CMS收集器</span>(有时甚至显著地)减少了<span class="highlight">老年代收集</span>的停顿时间，而代价是<span class="highlight">略有增加的年轻代收集的停顿时间</span>(想一想<span class="highlight">在<span class="highlight">年轻代对象晋升至老年代时</span>，老年代需要通过<span class="highlight">链表找到一块足够大的空闲内存块</span>，而不是像<span class="highlight">并行收集器</span>使用了<span class="highlight">bump-the-pointer技术</span>)、<span class="highlight">吞吐量的一些损失</span>和<span class="highlight">额外的堆空间需求</span>。
	</p>
	<li>
		<h4>增量模式</h4>
	</li>
	<p class="wrap">
		<span class="highlight">CMS收集器</span>可以采用让<span class="highlight">并发阶段增量完成的模式运行</span>。这种模式，通过对并发阶段的<span class="highlight">周期性暂停</span>把CPU让给应用程序，以减少<span class="highlight">并发阶段持续时间过长</span>所带来的不利影响。收集工作被分成许多小的时间块，它们在<span class="highlight">年轻代收集的间歇期</span>被调度，当应用程序既需要<span class="highlight">CMS收集器</span>提供的低停顿时间，又只能在很少的CPU(1到2个)上运行时，这个特性就相当有用。		
	</p>
	<li>
		<h4>何时使用CMS收集器？</h4>
	</li>
	<p class="wrap">
		如果应用程序需要<span class="highlight">更短的垃圾收集停顿时间</span>并且能够承担在运行时和垃圾收集器共享处理器资源，那么就可以使用<span class="highlight">CMS收集器</span>(由于其并发性，在垃圾收集过程中<span class="highlight">CMS收集器将和应用程序抢夺CPU周期)。通常来说，具有长时间存活的数据集并且运行在２个或多个CPU上的应用程序，更容易受益于CMS收集器的使用，一个典型的例子就是WEB应用。对于任何需要低停顿时间的应用程序来说，<span class="highlight">CMS收集器</span>都值得考虑。对于老年代大小适中并且运行在单一处理器上的交互式应用程序来说，使用ＣＭＳ收集器同样可能取得不错的效果。	
	</p>
	<li>
		<h4>选择CMS收集器</h4>
	</li>
	<p class="wrap">
		<span class="highlight">CMS收集器只能通过命令行选项<span class="highlight">-XX:+UseConcMarkSweepGC</span>进行显示的选用。如果希望<span class="highlight">CMS收集器</span>在增量模式下运行，还需要通过命令行选项<span class="highlight">-XX:+CMSIncrementalMode</span>启用该模式。
	</p>


	<li>
		<h2>HotSpot JVM中一些自动选择机制和调优</h2>
	</li>
	<p class="wrap">
		在J2SE 5.0版本中, <span class="highlight">HotSpot JVM</span>会根据应用程序运行时所在的<span class="highlight">平台和操作系统</span>，来设置默认的<span class="highlight">垃圾收集器</span>, <span class="highlight">堆大小</span>, <span class="highlight">client或server VM类型</span>。这些自动选择机制将更好地匹配不同应用类型的需求，与比之前的版本相比，却只需要更少的命令行参数，这正是JVM的工程学精髓。
	</p>
	<li>
		<h3>JVM默认选择的垃圾收集器，堆大小和虚拟机类型</h3>
	</li>
	<p class="wrap">
		首先需要了解下<span class="highlight">服务器级硬件</span>的定义(<span class="highlight">适用于除了32位Windows之外的所有平台</span>):
	</p>
	<div class="ui bulleted list">
    	<div class="item">
		  	拥有2个或以上的物理处理器	
    	</div>
    	<div class="item">
    		拥有2GB或以上的物理内存  		
    	</div>
	</div>
	<p id="default-heap" class="wrap">
		对于<span class="highlight">服务器级硬件</span>和<span class="highlight">非服务器级硬件</span>，<span class="highlight">HotSpot JVM</span>会作如下的默认选择:
	</p>
	<table class="ui celled teal small table">
    	<thead>
    		<tr>
    			<th class="center aligned">服务器级别 / 选项配置</th>
    			<th class="center aligned">VM类型</th>
    			<th class="center aligned">垃圾收集器</th>
    			<th class="center aligned">初始堆大小</th>
    			<th class="center aligned">最大堆大小</th>
    		</tr>
    	</thead>
    	<tbody>
    		<tr>
    			<td class="center aligned">服务器级硬件</td>
    			<td class="center aligned">
    				server
    			</td>
    			<td class="center aligned">
    				<a href="#parallel-gc">并行垃圾收集器</a>
    			</td>
    			<td class="center aligned">
    				物理内存/64(上限1G)
    			</td>
    			<td class="center aligned">
    				物理内存/4(上限1G)
    			</td>
    		</tr>
    		<tr>
    			<td class="center aligned">非服务器级硬件</td>
    			<td class="center aligned">
    				client
    			</td>
    			<td class="center aligned">
    				<a href="#serial-gc">串行垃圾收集器</a>
    			</td>
    			<td class="center aligned">
    				4M
    			</td>
    			<td class="center aligned">
    				64M
    			</td>
    		</tr>
    	</tbody>
	</table>
	<p class="wrap">
		注意，在<span class="highlight">服务器级硬件</span>上，无论用户是否手动设置<span class="highlight">-server</span>或<span class="highlight">-client</span>，默认垃圾收集器均为<a href="#parallel-gc">并行垃圾收集器</a>。
	</p>
	<li>
		<h3>并行垃圾收集器调优</h3>
	</li>
	<p class="wrap">
		在J2SE 5.0版本中, 对<span class="highlight">并行垃圾收集器</span>加入了一些可选参数，用户可以通过配置一些可选项，来使应用达到预期的<span class="highlight">暂停时间</span>和<span class="highlight">吞吐量</span>目标:
	</p>
	<li>
		<h4>最大暂停时间</h4>
	</li>
	<p class="wrap">
		用户可以通过<span class="highlight">-XX:MaxGCPauseMillis=n</span>设置在执行垃圾收集时，应用程序被暂停的最大时间(毫秒)。<span class="highlight">并行垃圾收集器</span>会通过调整<span class="highlight">堆大小</span>和<span class="highlight">其他垃圾回收相关的参数</span>来保证垃圾收集暂停时间小于n毫秒，这可能会降低应用程序的吞吐量，在某些情况下，暂停时间目标可能无法满足。
	</p>
	<p class="wrap">
		<span class="highlight">最大暂停时间</span>是针对不同代独立起作用的。比较典型的是，当最大暂停时间目标未达到时，垃圾收集器会减少分代的内存空间，来尝试达到该目标。<span class="highlight">MaxGCPauseMillis</span>默认不会设置。
	</p>
	<li>
		<h4>吞吐量</h4>
	</li>
	<p class="wrap">
		<span class="highlight">吞吐量</span>可以通过<span class="highlight">-XX:GCTimeRatio=n</span>参数来设置<span class="highlight">垃圾收集时间占比</span>，该值为<span class="highlight">1 / (1 + n)</span>。若设置<span class="highlight">-XX:GCTimeRatio=19</span>，则垃圾收集时间占5%，若该目标未达到，垃圾收集器会增大分代的内存空间，以增加应用程序在两次垃圾收集之间的运行时间。<span class="highlight">GCTimeRatio</span>默认为99，即垃圾收集时间占1%。
	</p>
	<li>
		<h4>空间占用</h4>
	</li>
	<p class="wrap">
		当<span class="highlight">最大暂停时间</span>和<span class="highlight">吞吐量</span>目标均达到后，垃圾收集器会减少堆空间，来使其中一个目标无法达到(但总是<span class="highlight">吞吐量目标</span>)。
	</p>
	<li>
		<h4>优先级</h4>
	</li>
	<p class="wrap">
		<span class="highlight">并行垃圾收集器</span>会优先尝试达成<span class="highlight">最大暂停时间</span>目标，然后再尝试达成<span class="highlight">吞吐量</span>目标，同样，前两个目标达成后，则会尝试达成<span class="highlight">空间占用</span>。
	</p>


	<li>
		<h2>建议</h2>
	</li>
	<p class="wrap">
		对于垃圾收集器的选择，最简单的建议就是<span class="highlight">什么也不用做</span>，尽量让JVM根据系统和平台自由选择，然后测试应用性能，若性能可接受，即<span class="highlight">暂停时间</span>和<span class="highlight">吞吐量</span>都能达到预期，就可以不作任何配置。
	</p>
	<p class="wrap">
		如果应用确实出现了与垃圾收集器相关的性能问题，最直接的想法应该是想想<span class="highlight">默认的垃圾收集器</span>是否适合当前的应用。然后尝试选择认为合适的垃圾收集器，并测试应用性能是否达到预期。
	</p>
	<li>
		<h3>何时选用不同的垃圾收集器</h3>
	</li>
	<p class="wrap">
		正如上面所说，当应用出现了与垃圾收集器相关的性能问题时，则可以选择不同的垃圾收集器进行性能测试，可以用如下的参数启用不同的垃圾收集器:
	</p>
	<div class="ui bulleted list">
    	<div class="item">
		  	启用<span class="highlight">串行收集器</span>：<span class="highlight">–XX:+UseSerialGC</span>
    	</div>
    	<div class="item">
		  	启用<span class="highlight">并行收集器</span>：<span class="highlight">–XX:+UseParallelGC</span>
    	</div>
    	<div class="item">
		  	<span class="highlight">老年代</span>启用<span class="highlight">并行压缩收集器</span>：<span class="highlight">–XX:+UseParallelOldGC</span>
    	</div>
    	<div class="item">
		  	<span class="highlight">老年代</span>启用<span class="highlight">并发标记清理收集器</span>：<span class="highlight">-XX:+UseConcMarkSweepGC</span>
    	</div>
	</div>
	<li>
		<h3>堆大小</h3>
	</li>
	<p class="wrap">
		通常默认的堆大小在生产环境是不够用的，需要作出一些调整，可以通过<span class="highlight">–Xmx</span>来设置，建议可以将<span class="highlight">–Xms</span>也设置和<span class="highlight">–Xmx</span>一样，比如都设置为2G或4G等。若不是<span class="highlight">暂停时间过长</span>问题，可将堆大小设置大一些，<span class="highlight">足够大的堆</span>是影响垃圾收集性能最大的因素。
	</p>
	<p class="wrap">
		当决定了使用的堆大小后，可以先使用默认的分代大小分配策略，进行性能观察，若未能达到预期，可以尝试调整不同分代的内存大小。影响垃圾收集的性能的第二个最有影响力的因素是<span class="highlight">堆中年轻代的占有比例</span>。若不是发现<span class="highlight">老年代收集过于频繁</span>或者<span class="highlight">暂停时间过长</span>，可以分配多一些内存给<span class="highlight">年轻代</span>。若垃圾收集器使用的<span class="highlight">串行收集器</span>，年轻代大小不应该超过堆的一半。
	</p>
	<p class="wrap">
		若垃圾收集器使用的是<span class="highlight">并行收集器</span>时，最好设置预期的性能参数，而不是确切的堆大小或分代占用比例，让垃圾收集器自动动态地调整堆大小来满足预期的性能。
	</p>
	<li>
		<h3>并行收集器调优</h3>
	</li>
	<p class="wrap">
		当使用<span class="highlight">并行垃圾收集器</span>或<span class="highlight">并行压缩垃圾收集器</span>时，最直观的是定义一个<span class="highlight">吞吐量目标</span>，剩下的就交给收集器自由调整来达到该目标。
	</p>
	<p class="wrap">
		若堆已经增加到最大(<span class="highlight">Xmx</span>)，但仍未达到<span class="highlight">吞吐量目标</span>，可以将堆大小设置到接近物理内存，若最后仍不能达到<span class="highlight">吞吐量目标</span>，则该<span class="highlight">吞吐量目标</span>对于应用所在服务器设置偏高。
	</p>
	<p class="wrap">
		若<span class="highlight">吞吐量目标</span>目标达成，但<span class="highlight">暂停时间过长</span>，可以设置<span class="highlight">最大暂停时间</span>，这势必会降低<span class="highlight">吞吐量</span>，所以这是一个权衡的过程。
	</p>
	<li>
		<h3>如何处理OutOfMemoryError</h3>
	</li>
	<p class="wrap">
		<span class="highlight">java.lang.OutOfMemoryError</span>算是一个常见的问题，这个错误在没有足够的空间分配对象时抛出。也就是说，<span class="highlight">垃圾收集器</span>不能再使用一些空间来容纳一个新对象，并且堆空间不能再扩展。<span class="highlight">OutOfMemoryError</span>错误不一定意味着<span class="highlight">内存泄露</span>。它可能是一个简单的<span class="highlight">配置错误</span>，例如为应用程序配置不足的内存(或默认值没有设置)。诊断<span class="highlight">OutOfMemoryError</span>错误的第一步是检查完整的错误信息，在异常信息中，有一些额外信息在<span class="highlight">java.lang.OutOfMemoryError</span>之后，下面一些常见的可能的补充信息，以及他们是什么意思，针对他们该做些什么:
	</p>
	<div class="ui bulleted list">
    	<div class="item">
		  	<strong>Java heap space</strong>
    	</div>
    	<p class="wrap">
    		这表明对象不能在堆中分配，这个可能仅仅是一个配置问题。例如，通过命令行参数-Xmx指定的（或者默认的）最大堆内存对于应用来说是过小，你就会遇到这个错误。它也可能是一种迹象，不再需要的对象由于应用程序无意的引用着而不能被垃圾收集器回收，也可以说是<span class="highlight">内存泄露</span>。<span class="highlight">HAT工具</span>可以用来查看所有可引用到的对象，以及理解这些对象是如何被引用的。另一个可能导致这个错误的原因可能是应用过多的使用<span class="highlight">终结器(finalizers)</span>以至于执行终结的线程跟不上加入终结队列的速度，<span class="highlight">jconsole工具</span>可以用来监测等待终结的对象数量。
    	</p>
    	<div class="item">
		  	<strong>PermGen space</strong>
    	</div>
    	<p class="wrap">
    		这表明<span class="highlight">永久代</span>满了，如前所述，这个区域是JVM用来存放<span class="highlight">元数据信息</span>的,如果应用程序加载了大量的类，则需要增加<span class="highlight">永久代</span>大小，可以通过命令行参数<span class="highlight">–XX:MaxPermSize=n</span>来设置<span class="highlight">永久代</span>大小。
    	</p>
    	<div class="item">
		  	<strong>Requested array size exceeds VM limit</strong>
    	</div>
    	<p class="wrap">
    		这表明应用分配的数组对象大小比堆还大，例如，应用程序尝试分配一个512MB的数组，但是堆最大才256MB，就会出现这个错误。大部分情况下，这个错误要不就是因为堆太小，要不就是因为应用程序计算数组的大小时发生错误引起了一个bug。
    	</p>
	</div>
	<li>
		<h3>评估垃圾收集器性能的工具</h3>
	</li>	
	<p class="wrap">
		日常中，可以用不同的调试和监控工具来评估垃圾收集性能，下面将介绍一些常用的工具。
	</p>
	<li>
		<h3>-XX:+PrintGCDetails</h3>
	</li>
	<p class="wrap">
		<span class="highlight">-XX:+PrintGCDetails</span>用于打印每次垃圾收集的相关信息，如<span class="highlight">不同分代在垃圾收集前后的存活对象大小</span>，<span class="highlight">不同分代的可用空间</span>，<span class="highlight">垃圾收集耗时</span>等。
	</p>
	<li>
		<h3>-XX:+PrintGCTimeStamps</h3>
	</li>
	<p class="wrap">
		<span class="highlight">-XX:+PrintGCTimeStamps</span>用于打印每次<span class="highlight">垃圾收集开始的时间戳</span>。
	</p>
	<p class="wrap">
		为了当生产线上出现OOM等崩溃问题时，会建议开启一些帮助解决问题的选项，如:
	</p>
	{% highlight java %}
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump_dir -Xloggc:gc.log
	{% endhighlight %}
	<li>
		<h3>其他常用工具</h3>
	</li>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				<a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jmap.html" target="_blank">jmap</a>
			</strong>
    	</div>
    	<p class="wrap">
    		用来输出JVM的内存相关的统计, 如果没有任何选项参数, 它会输出加载的对象列表. 需要更详细的信息, 可以使用<span class="highlight">-heap, -histo, -permstat</span>参数。  
    	</p>
    	<div class="item">
    		<strong>	
				<a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html" target="_blank">jstat</a>
			</strong>   	
    	</div>
    	<p class="wrap">
    		用来输出程序<span class="highlight">运行时的资源占用和性能信息</span>，它可以用来诊断性能问题, 特别是跟堆大小以及垃圾回收相关的问题。
    	</p>
    	<div class="item">
			<strong>
				<a href="http://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html" target="_blank">HPROF</a>
			</strong>
    	</div>
    	<p class="wrap">
    		是一个简单的<span class="highlight">profiler agent</span>。它是一个使用<span class="highlight">Java Virtual Machine Tools Interface (JVM TI) </span>的<span class="highlight">JVM动态链接库接口</span>。它可以输出一些监测信息到文件中, 这个文件以后可以被性能分析工具用来分析性能问题。
    	</p>
    	<div class="item">
    		<strong>
    			<a href="http://jovial.com/hat/doc/README.html" target="_blank">HAT</a>	
    		</strong>	
    	</div>
    	<p class="wrap">
    		可以用来分析对象的引用关系。结合hprof文件分析，解决一些<span class="highlight">内存泄露</span>的问题。
    	</p>
	</div>


	<li>
		<h2>垃圾收集相关的关键参数</h2>
	</li>
	<p class="wrap">
		JVM提供了一些命令行选项来<span class="highlight">选择垃圾收集器</span>，<span class="highlight">定义堆或分代的大小</span>，<span class="highlight">调整垃圾收集的行为</span>和<span class="highlight">获取垃圾收集数据</span>等。下面将介绍一些常用的选项:
	</p>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				垃圾收集器选择
			</strong>
    	</div>
    	<table class="ui celled teal small table">
	    	<thead>
	    		<tr>
	    			<th>选项</th>
	    			<th>垃圾收集器</th>
	    		</tr>
	    	</thead>
	    	<tbody>
	    		<tr>
	    			<td>
	    				–XX:+UseSerialGC
	    			</td>
	    			<td>
	    				串行收集器
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+UseParallelGC
	    			</td>
	    			<td>
	    				并行收集器
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+UseParallelOldGC
	    			</td>
	    			<td>
	    				并行压缩收集器，针对老年代
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+UseConcMarkSweepGC
	    			</td>
	    			<td>
	    				并发-标记-清理收集器(CMS)，针对老年代
	    			</td>
	    		</tr>
	    	</tbody>
		</table>
	</div>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				垃圾收集器统计
			</strong>
    	</div>
    	<table class="ui celled teal small table">
	    	<thead>
	    		<tr>
	    			<th>选项</th>
	    			<th>描述</th>
	    		</tr>
	    	</thead>
	    	<tbody>
	    		<tr>
	    			<td>
	    				–XX:+PrintGC
	    			</td>
	    			<td>
	    				每次垃圾收集的基本信息
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+PrintGCDetails
	    			</td>
	    			<td>
	    				每次垃圾收集的详细信息
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+PrintGCTimeStamp
	    			</td>
	    			<td>
	    				每次垃圾收集开始的时间戳
	    			</td>
	    		</tr>
	    	</tbody>
		</table>
	</div>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				堆和分代大小
			</strong>
    	</div>
    	<table class="ui celled teal small table">
	    	<thead>
	    		<tr>
	    			<th width="25%">选项</th>
	    			<th>默认值</th>
	    			<th>描述</th>
	    		</tr>
	    	</thead>
	    	<tbody>
	    		<tr>
	    			<td>
	    				–Xmsn
	    			</td>
	    			<td>
	    				<a href="#default-heap">见这里</a>
	    			</td>
	    			<td>
	    				起始堆大小
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–Xmxn
	    			</td>
	    			<td>
	    				<a href="#default-heap">见这里</a>
	    			</td>
	    			<td>
	    				最大堆大小
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				-XX:MinHeapFreeRatio=n
	    			</td>
	    			<td>
	    				40
	    			</td>
	    			<td>
	    				针对每一个代，空闲内存最小占比，当空间内存占比小于该值时，分代大小将扩大
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				-XX:MaxHeapFreeRatio=n
	    			</td>
	    			<td>
	    				70
	    			</td>
	    			<td>
	    				针对每一个代，空闲内存最大占比，当空间内存占比大于该值时，分代大小将缩小
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:NewSize=n
	    			</td>
	    			<td>
	    				平台依赖
	    			</td>
	    			<td>
	    				年轻代初始大小
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:NewRatio=n
	    			</td>
	    			<td>
	    				client VM时，为2；server VM时，为8
	    			</td>
	    			<td>
	    				年轻代与老年代比例。若n=3，则年轻代占堆大小的1/4
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:SurvivorRatio=n
	    			</td>
	    			<td>
	    				32
	    			</td>
	    			<td>
	    				年轻代中每一个<span class="highlight">Survivor区</span>与<span class="highlight">Eden区</span>占比。若n=7，则<span class="highlight">From:To:Eden=1:1:7</span>
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:MaxPermSize=n
	    			</td>
	    			<td>
	    				平台依赖
	    			</td>
	    			<td>
	    				永久代最大大小
	    			</td>
	    		</tr>
	    	</tbody>
		</table>
	</div>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				并行收集器和并行压缩收集器
			</strong>
    	</div>
    	<table class="ui celled teal small table">
	    	<thead>
	    		<tr>
	    			<th width="25%">选项</th>
	    			<th>默认值</th>
	    			<th>描述</th>
	    		</tr>
	    	</thead>
	    	<tbody>
	    		<tr>
	    			<td>
	    				–XX:ParallelGCThreads=n
	    			</td>
	    			<td>
	    				CPU个数
	    			</td>
	    			<td>
	    				垃圾收集线程数
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:MaxGCPauseMillis=n
	    			</td>
	    			<td>
	    				无
	    			</td>
	    			<td>
	    				垃圾收集最大暂停时间
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:GCTimeRatio=n
	    			</td>
	    			<td>
	    				99
	    			</td>
	    			<td>
	    				垃圾收集所占时间比: n / (n+1)
	    			</td>
	    		</tr>
	    	</tbody>
		</table>
	</div>
	<div class="ui bulleted list">
    	<div class="item">
			<strong>
				CMS收集器
			</strong>
    	</div>
    	<table class="ui celled teal small table">
	    	<thead>
	    		<tr>
	    			<th width="25%">选项</th>
	    			<th>默认值</th>
	    			<th>描述</th>
	    		</tr>
	    	</thead>
	    	<tbody>
	    		<tr>
	    			<td>
	    				XX:+CMSIncrementalMode
	    			</td>
	    			<td>
	    				否
	    			</td>
	    			<td>
	    				开启并发阶段增量模式，周期性停止执行并发阶段，将CPU让给应用程序
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:+CMSIncrementalPacing
	    			</td>
	    			<td>
	    				否
	    			</td>
	    			<td>
	    				当JVM在运行时，依据收集的统计信息启用增量模式自动调节占空比
	    			</td>
	    		</tr>
	    		<tr>
	    			<td>
	    				–XX:ParallelGCThreads=n
	    			</td>
	    			<td>
	    				CPU个数
	    			</td>
	    			<td>
	    				年轻代并行收集的线程数和老年代并发阶段的线程数
	    			</td>
	    		</tr>
	    	</tbody>
		</table>
	</div>

	<p class="wrap">
		以上则是<span class="highlight">Java内存管理</span>的一些基础知识，将有助于你在遇到内存相关问题时，提供一些指引，遇到这类问题，不用慌张，往往问题没有想象那么复杂，而大多数情况只是配置问题或者程序问题。
	</p>

	<li>
    	<h2>参考文献</h2>
    </li>
	<p class="wrap">
		<a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank">http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf</a><br>
		<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a>
		<a href="http://stackoverflow.com/questions/20430058/parallel-compacting-collector-algorithm" target="_blank">http://stackoverflow.com/questions/20430058/parallel-compacting-collector-algorithm</a>
		<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html</a>
		<a href="http://blog.sina.com.cn/s/blog_515015800100gwu6.html" target="_blank">http://blog.sina.com.cn/s/blog_515015800100gwu6.html</a>
	</p>


</ul>
