---
title : Redis 3.0 集群
category : [redis]
tags : [redis, cluster]
layout : post
show : 0
keywords: redis,cluster,redis集群
---

<ul>
    <p class="intro">
        Redis3.0之前是原生是不支持<span class="highlight">集群功能</span>的，
        但通过其他一些工具，如<a href="https://github.com/twitter/twemproxy" target="_blank">twenproxy</a>
        可以将多个Redis实例组合成一个集群，通过该代理实现<span class="highlight">负载均衡</span>等功能，
        但其本身对某些Redis命令<a href="https://github.com/twitter/twemproxy/blob/master/notes/redis.md" target="_blank">并不支持</a>，如<span class="highlight">BLPOP</span>，
        <span class="highlight">Pub/Sub</span>，<span class="highlight">Transactions</span>等，
        Redis3.0之后开始原生支持集群功能，本文将了解下Redis3.0的集群部分。
    </p>


    <li>
        <h2>主要的设计原理和特性</h2>
    </li>
    <li>
        <h3>Redis集群的实现目标</h3>
    </li>
    <p class="wrap">
       <span class="highlight">Redis集群</span>即Redis的分布式实现，按其目标重要性排序，大概有几个: 
    </p>
    <ul>
        <li>
        1. <span class="highlight">高性能</span>且支持1000+节点<span class="highlight">线性扩展</span>。
    集群中不会有<span class="highlight">代理</span>，<span class="highlight">异步复制</span>等操作，在获取值时<span class="highlight">不会有合并操作</span>。</li>
        <li>
            2. <span class="highlight">可接受的写安全</span>。系统以最佳的方式保留了所有与多数master节点连接的客户端的写操作，
    但通常还是有一些小窗口会丢失写操作，并且当客户端在<span class="highlight">少数分区</span>时，丢失的写操作将更多。
        </li>
        <li>
            3. <span class="highlight">可用性</span>。集群可以比多数可用的master节点分区存活更久，
            并且对每一个不可用的master节点至少有一个可用的slave节点，此外，通过<span class="highlight">replicas migration</span>，不再被任何slave节点复制的master节点将从其对应slave节点中接受一个为master节点。
        </li>
    </ul>
    <li>
        <h3>Redis集群实现的功能子集</h3>
    </li>
    <p class="wrap">
        Redis集群实现了单机Redis中， 所有处理单个数据库Key的命令。对于一些负责的多Key命令，
        如Set的并集和交集操作，只要<span class="highlight">所有这些Key都在同一节点上</span>也是可以的。<br/>
        Redis集群通过一个叫<span class="highlight">hash tags</span>的方式来强制某些Key存储在
        <span class="higlight">同一个节点</span>上，但是在<span class="">手动分片</span>过程中，
        多Key操作有时变得不可用，然而单Key操作始终是可用的。<br/>
        Redis集群不支持像单机Redis中的多数据库，只有<span class="highlight">DB 0</span>可用，
        即<span class="highlight">SELECT</span>命令在Redis集群中不支持。
    </p>
    <li>
        <h3>Redis集群协议中的客户端和服务器</h3>
    </li>
    <li>
        Redis 集群中的节点有以下责任：
    </li>
    <ul>
        <li>
            1. 持有键值对数据。
        </li>
        <li>
            2. 记录集群的状态，包括键到正确节点的映射。
        </li>
        <li>
            3. 自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。
        </li>
    </ul>
    <p class="wrap">
        集群中所有的节点都通过一个<span class="highlight">TCP总线</span>和二进制协议
        (叫做<span class="highlight">Redis集群总线</span>)来完成自己的任务。
        节点之间通过Gossip协议进行一下工作：
    </p>
    <ul>
        <li>
            1. 传播（propagate）关于集群的信息，以此来发现新的节点;
        </li>
        <li>
            2. 向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作;
        </li>
        <li>
            3. 在特定事件发生时，发送集群信息;
        </li>
        <Li>
            4. 在集群中发布或订阅信息。
        </Li>
    </ul>
    <p class="wrap">
        因为集群节点<span class="highlight">不能代理（proxy）</span>命令请求， 所以客户端应该在节点返回
        <span class="highlight"> -MOVED </span>或者 <span class="highlight">-ASK </span>转向（redirection）错误时， 自行将命令请求转发至其他节点。因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。不过， 如果<span class="highlight">客户端可以将键和节点之间的映射信息缓存起来</span>， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。
    </p>
    <li>
        <h3>写安全</h3>
    </li>
    <p class="wrap">
        Redis集群中节点之间使用<span class="highlight">异步复制</span>，
        并且最终被选举的Master的数据将替换所以其他的副本。
        在分区过程中，总是有一个<span class="highlight">窗口</span>时间内有可能发生写丢失。
        但是这些<span>窗口</span>对于连接到多数Master端和少数Master端的客户端却不尽相同，
        相较于少数Master端的写操作，Redis集群会尽量记住多数Master端的写操作。
        下面是一些在故障期间，多数分区丢失写操作的场景:
    </p>
    <ul>
        <li>
            1. 一个写操作到达了Master，且Master回复了客户端，但是该写操作并并没有通过
            <span class="highlight">异步复制</span>给Slave。如果写操作在达到Slave前，
            Master崩溃了，并且该Master在新Master出现前还不可用时，该写操作将永久丢失。
            通常，很难遇到这种情况，但确实是现实中存在的一种故障情形。
        </li>
        <li>
            2. 另外理论上写操作丢失的情形可能有这些:
        </li>
        <ul>
            <li>
                Master由于分区不可用；
            </li>
            <li>
                Slave发生故障；
            </li>
            <li>
                一段时间后，节点才再次可用；
            </li>
            <li>
                Client使用了过期的路由表，向旧的Master发送请求。
            </li>
        </ul>
    </ul>
    <p class="wrap">
        实际上这是极小概率事件，这是因为，那些由于长时间无法被大多数主节点访问到的节点会被故障转移掉，不再接受任何写入操作，当其分区修复好以后仍然会在一小段时间内拒绝写入操作好让其他节点有时间被告知配置信息的变更。通常所有节点都会尝试通过非阻塞连接尝试（non-blocking connection attempt）尽快去访问一个再次加入到集群里的节点，一旦跟该节点建立一个新的连接就会发送一个ping包过去（这足够升级节点配置信息）。这就使得一个节点很难在恢复可写入状态之前没被告知配置信息更改。
    </p>
    <p class="wrap">
        Redis 集群在拥有少数主节点和至少一个客户端的分区上容易丢失为数不少的写入操作，这是因为如果主节点被故障转移到集群中多数节点那边的节点上， 那么所有发送到这些主节点的写入操作都会永久性丢失。
    </p>
    <p class="wrap">
        一个主节点要被故障转移，必须是大多数主节点在至少NODE_TIMEOUT 这么长时间里无法访问该节点，所以如果分区在这段时间之前修复好了，就没有写入操作会丢失。当分区故障持续超过 NODE_TIMEOUT，集群的多数节点这边会在一超过 NODE_TIMEOUT这个时间段后开始拒绝往受损分区进行写入，所以在少数节点这边（指分区）变得不再可用后，会有一个写入操作最大损失范围（因为在指定时间段后将不会再有写入操作被接收或丢失）。
    </p>    
    <li>
        <h3>可用性</h3>
    </li>
    <p class="wrap">
        Redis集群在分区的少数节点上是不可用的。假设集群中分区的大部分Mater节点都可达，并且每个不可达的Master节点都至少有一个对应的Slave节点可达，那么在经过<span class="highlight">NODE_TIMEOUT</span>加上该Slave节点被选举为master的时间后(故障转移通常需要1s到2s)，集群将再次可用。
        这意味着Redis集群的设计是能容忍集群中少数节点故障，但对于要求在大量网络分块时也可用的应用来说，这并不是一个合适的解决方案。
    </p>
    <p class="wrap">
        比如，一个由N个Master节点构成的集群，并且每个Master节点都有一个Slave节点，当有一个节点（因为故障）被分割出去后，集群的多数节点仍然是可访问的，
        当有两个节点（因故障）被分割出去后集群仍可用的概率是<span class="highlight">1-(1/(N*2-1))</span>在第一个节点故障出错后总共剩下 N*2-1 个节点，那么失去冗余备份（即失去从节点）的那个主节点故障出错的概率就是<span class="highlight">1/(N*2-1))</span>。<br>
        比如一个拥有5个节点的集群，每个节点都只有一个从节点，那么在两个节点从多数节点这边分割出去后集群不再可用的概率是1/(5*2-1)=0.1111，即有大约 11% 的概率。<br>
        得益于Redis集群中叫做<span class="highlight">备份迁移(replicas migration)</span>的特性，该特性通过将备份迁移到<span class="highlight">孤立的Master节点(没有Slave备份节点)</span>, 从而提升了集群在真实环境中的可用性。因此在每一次故障后，集群为了更好地抵御下一次故障，会重新配置Slave节点布局。
    </p>
    <li>
        <h3>性能</h3>
    </li>
    <p class="wrap">
        Redis集群不会负责将命令转发到正确的节点上，而是将客户端请求重定向到正确的节点上。
        最终客户端获得最新的集群信息，其中包含哪些节点拥有哪些键值子集，
        这样在正常操作中，客户端就可以直接连接到对应的节点并把命令发过去。
        由于使用了异步冗余备份，节点不会等待其他节点对写入操作的确认(除非明确地使用<span class="highlight">WAIT</span>命令)。
        而且，多Key操作仅限于同一节点上的，除了进行<span class="highlight">重新分片(resharding)</span>，数据将不会移动。
        普通操作是可以被处理得跟在单例Redis上一样的。这意味着，在一个拥有N个主节点的Redis集群中，由于Redis 的设计是支持线性扩展的，所以你可以认为同样的操作在集群上的表现会跟在单例Redis上的表现乘以N一样。同时，查询(query)通常在一次循环中被执行，客户端会保持跟节点持续不断的连接，所以延迟数据跟在单一Reids上是一样的。
    </p>
    <li>
        <h3>为什么要避免合并操作</h3>
    </li>
    <p class="wrap">
        Redis集群的设计是避免在多个节点中存在同个键值对的冲突版本，Redis中的值通常都是比较大的，比如
        <span class="highlight">List，Set</span>数据结构通常都有几百万个元素，数据类型在语义上也是比较复杂的，
        传输和合并这样的值，需要应用层逻辑的参与，额外的内存保存元数据等，这将会变成一个主要的性能瓶颈。<br>
        这里并没有严格的技术限制，
        <a href="http://www.tuicool.com/articles/a63eiu" target="_blank">CRDT</a>s和<span class="highlight">同步备份状态机</span>
        可以模拟出类似Redis这样复杂的数据类型。然而，这种系统实际的运行表现并不类似于Redis集群，
        Redis集群被设计来覆盖非集群Redis版本的具体用例。
    </p>
    <li>
        <h2>Redis集群中的主要组件</h2>
    </li>

</ul> 






