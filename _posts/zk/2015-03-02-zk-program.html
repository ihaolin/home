---
title : Zookeeper深入理解(二)(编程实践)
category : [zookeeper]
tags : [zookeeper, program]
layout : post
show : 1
keywords: zookeeper，编程，实践
---

<ul>
    <p class="intro">
        本文将讲述如何使用<span class="highlight">Zookeeper Client API</span>进行编程，
        以在分布式应用中实现<span class="highlight">协调</span>功能，
        <span class="highlight">Zookeeper</span>支持Java和C的API，本文主要使用Java语言。
    </p>

    <li>
        <h2>使用Zookeeper API</h2>
    </li>
    <li>
        <h3>首先添加Maven依赖</h3>
    </li>
    {% highlight xml %}
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.4.6</version>
</dependency>
    {% endhighlight %}
    <li>
        <h3>创建Zookeeper会话</h3>
    </li>
    <li>
        Zookeeper API会围绕一个<span class="highlight">Zookeeper 句柄</span>，通过该句柄来调用各种API，该句柄也就是
        <span class="highlight">Zookeeper会话</span>。如果会话连接断开了，该会话会被迁移到另一台Server上(如图)，只要会话仍然存活着，
        该句柄将一直有效，Client就会持续保持和Server的连接，若句柄被关掉，Client将告诉Server关掉会话。
    </li>
    <img src="{{site.url}}/images/zk/session-migrate.jpg">
    <li>
        Zookeeper提供了一个创建句柄的构造器
    </li>
    {% highlight java %}
/**
 * connectString: server列表，如127.0.0.1:2182,127.0.0.1:2183,127.0.0.1:2184
 * sessionTimeout: 如果Server超过该时间(毫秒)没能和Client通信，Server将关闭此次会话，通常为5 ~ 10秒。
 * watcher: 用于接收Session事件，该事件会在会话建立，关闭或过期时产生，Client也可以用于监控Zookeeper数据变化。
 */
ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)
    {% endhighlight %}
    <li>
        <h3>
            实现Watcher
        </h3>
    </li>
    <li>
        为了收到Zookeeper的通知，我们需要实现Watcher接口
    </li>
    {% highlight java %}
public interface Watcher {
    void process(WatchedEvent event);
}
    {% endhighlight %}
    <li>
        比如，我们可以实现一个<span class="highlight">Master</span>
    </li>
    {% highlight java %}
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import java.io.IOException;

/**
* Author: haolin
* On: 3/4/15
*/
public class Master implements Watcher {

    private ZooKeeper zk;

    private String connnectHost;

    public Master(String connnectHost){
        this.connnectHost = connnectHost;
    }

    public void startZK() throws IOException {
        zk = new ZooKeeper(connnectHost, 15000, this);
    }

    @Override
    public void process(WatchedEvent event) {
        System.out.print(event);
    }

    public static void main(String[] args) throws Exception {
        String connnectHost = "localhost:2181";
        Master m = new Master(connnectHost);
        m.startZK();
        // wait for a bit
        Thread.sleep(60000);
    }
}
    {% endhighlight %}
    <li>
        运行上面的程序则会看到如下日志
    </li>
    {% highlight console %}
2015-03-04 23:36:05,661 - INFO  - [main:Environment@100] - Client environment:zookeeper.version=3.4.6-1569965, built on 02/20/2014 09:09 GMT
2015-03-04 23:36:05,664 - INFO  - [main:Environment@100] - Client environment:host.name=192.168.0.102
2015-03-04 23:36:05,667 - INFO  - [main:Environment@100] - Client environment:java.version=1.7.0_45
2015-03-04 23:36:05,667 - INFO  - [main:Environment@100] - Client environment:java.vendor=Oracle Corporation
2015-03-04 23:36:05,667 - INFO  - [main:Environment@100] - Client environment:java.home=/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre
2015-03-04 23:36:05,667 - INFO  - [main:Environment@100] - Client environment:java.class.path=/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/javafx-doclet.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/tools.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/htmlconverter.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/JObjC.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Users/haolin/Learning/langs/java/codes/kb/libraries/zkclient/target/classes:/Users/haolin/Envir/build/maven/m2/repos/org/slf4j/slf4j-api/1.7.1/slf4j-api-1.7.1.jar:/Users/haolin/Envir/build/maven/m2/repos/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/Users/haolin/Envir/build/maven/m2/repos/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.jar:/Users/haolin/Envir/build/maven/m2/repos/log4j/log4j/1.2.16/log4j-1.2.16.jar:/Users/haolin/Envir/build/maven/m2/repos/jline/jline/0.9.94/jline-0.9.94.jar:/Users/haolin/Envir/build/maven/m2/repos/io/netty/netty/3.7.0.Final/netty-3.7.0.Final.jar:/Users/haolin/Envir/build/maven/m2/repos/org/apache/curator/curator-recipes/2.1.0-incubating/curator-recipes-2.1.0-incubating.jar:/Users/haolin/Envir/build/maven/m2/repos/org/apache/curator/curator-framework/2.1.0-incubating/curator-framework-2.1.0-incubating.jar:/Users/haolin/Envir/build/maven/m2/repos/org/apache/curator/curator-client/2.1.0-incubating/curator-client-2.1.0-incubating.jar:/Users/haolin/Envir/build/maven/m2/repos/com/google/guava/guava/18.0/guava-18.0.jar:/Users/haolin/Envir/build/maven/m2/repos/org/projectlombok/lombok/1.12.2/lombok-1.12.2.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-core/3.2.6.RELEASE/spring-core-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-beans/3.2.6.RELEASE/spring-beans-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-context/3.2.6.RELEASE/spring-context-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-aop/3.2.6.RELEASE/spring-aop-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-expression/3.2.6.RELEASE/spring-expression-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-tx/3.2.6.RELEASE/spring-tx-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-context-support/3.2.6.RELEASE/spring-context-support-3.2.6.RELEASE.jar:/Users/haolin/Envir/build/maven/m2/repos/org/springframework/spring-jdbc/3.2.6.RELEASE/spring-jdbc-3.2.6.RELEASE.jar:/Applications/IntelliJ IDEA 14 EAP.app/Contents/lib/idea_rt.jar
2015-03-04 23:36:05,668 - INFO  - [main:Environment@100] - Client environment:java.library.path=/Users/haolin/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.
2015-03-04 23:36:05,668 - INFO  - [main:Environment@100] - Client environment:java.io.tmpdir=/var/folders/c4/1qgb32bj4_j734lwcs9lspsc0000gn/T/
2015-03-04 23:36:05,668 - INFO  - [main:Environment@100] - Client environment:java.compiler=<NA>
2015-03-04 23:36:05,668 - INFO  - [main:Environment@100] - Client environment:os.name=Mac OS X
2015-03-04 23:36:05,668 - INFO  - [main:Environment@100] - Client environment:os.arch=x86_64
2015-03-04 23:36:05,669 - INFO  - [main:Environment@100] - Client environment:os.version=10.10.3
2015-03-04 23:36:05,669 - INFO  - [main:Environment@100] - Client environment:user.name=haolin
2015-03-04 23:36:05,669 - INFO  - [main:Environment@100] - Client environment:user.home=/Users/haolin
2015-03-04 23:36:05,669 - INFO  - [main:Environment@100] - Client environment:user.dir=/Users/haolin/Learning/langs/java/codes/kb
2015-03-04 23:36:05,704 - INFO  - [main:ZooKeeper@438] - Initiating client connection, connectString=localhost:2181 sessionTimeout=15000 watcher=org.apache.zookeeper.book.practice.Master@6f85c59c
2015-03-04 23:36:05,965 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@975] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)
2015-03-04 23:36:05,972 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@852] - Socket connection established to localhost/127.0.0.1:2181, initiating session
2015-03-04 23:36:06,051 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@1235] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x14bbc76762e0005, negotiated timeout = 15000
WatchedEvent state:SyncConnected type:None path:null
    {% endhighlight %}
    <li>
        然而，当我们这时将server停掉，Client会尝试重新连接，并且Client也没有收到任何事件
    </li>
    {% highlight console %}
2015-03-04 23:47:55,667 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@975] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)
2015-03-04 23:47:55,669 - WARN  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@1102] - Session 0x14bbc76762e0006 for server null, unexpected error, closing socket connection and attempting reconnect
java.net.ConnectException: Connection refused
at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:735)
at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:361)
at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1081)
2015-03-04 23:47:57,771 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@975] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)
2015-03-04 23:47:57,771 - WARN  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@1102] - Session 0x14bbc76762e0006 for server null, unexpected error, closing socket connection and attempting reconnect
    {% endhighlight %}
    <li>
        再次启动server，Client再次接收到<span class="highlight">SyncConnected</span>事件
    </li>
    {% highlight console %}
2015-03-04 23:47:59,847 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@975] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)
2015-03-04 23:47:59,847 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@852] - Socket connection established to localhost/127.0.0.1:2181, initiating session
2015-03-04 23:47:59,877 - INFO  - [main-SendThread(localhost:2181):ClientCnxn$SendThread@1235] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x14bbc76762e0006, negotiated timeout = 15000
WatchedEvent state:SyncConnected type:None path:null
    {% endhighlight %}
    <li>
        既然Zookeeper Client能够自己尝试尽可能连接上Server，所以对于我们，<span class="highlight">尽量不要亲自去管理连接</span>。
    </li>
    <li>
        我们可以通过<span class="highlight">telnet</span>观察下Zookeeper状态，可以看到两个Client，一个是之前Master程序，一个就是当前telnet会话。
    </li>
    <img src="{{site.url}}/images/zk/zk-stat.jpg">
    <li>
        同样，我们还可以通过<span class="highlight">dump</span>查看一些会话信息，可以看到有一个会话(Master)
    </li>
    <img src="{{site.url}}/images/zk/zk-dump1.jpg">
    <li>
        如果现在我们关掉Master，其实会话并不会马上销毁，而会等到超时。最终才没有了会话
    </li>
    <img src="{{site.url}}/images/zk/zk-dump2.jpg">
    <li>
        当然我们也可以手动关闭连接，而不是等到超时
    </li>
    {% highlight java %}
public void stopZk() throws InterruptedException {
    zk.close();
}
    {% endhighlight %}
    <li>
        <h3>获取领导权(Mastering)</h3>
    </li>
    <li>
        现在我们希望<span class="highlight">Master</span>能够获取到<span class="highlight">领导权</span>，
        之前的文章讲述过，我们需要创建一个<span class="highlight">临时节点</span>如/master，若该节点已经存在，
        说明Master已经存在，否则自己将成为Master。
    </li>
    {% highlight java %}
// 标识自己
private String serverId = Integer.toHexString(random.nextInt());
// 是否是Leader
private boolean isLeader;

public void runForMaster() throws KeeperException, InterruptedException {
    while (true) {
        try {
            zk.create("/master", serverId.getBytes(),
                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
            // 创建/master节点成功
            isLeader = true;
            break;
        } catch (KeeperException.NodeExistsException e) {
            // /master已经存在
            isLeader = false;
            break;
        } catch (KeeperException.ConnectionLossException e) {
        }
        if (checkMaster()) break;
    }
}

/**
* 检查master是否存在
* @return 存在返回true，反之false
*/
private boolean checkMaster() throws InterruptedException{
    while (true) {
        try {
            Stat stat = new Stat();
            byte data[] = zk.getData("/master", false, stat);
            isLeader = new String(data).equals(serverId);
            return true;
        } catch (KeeperException.NoNodeException e) {
            // 没有master节点，可返回false
            return false;
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }
}
    {% endhighlight %}
    <li>
        这里，我们创建节点时，指明了节点的权限控制
        <span class="highlight">OPEN_ACL_UNSAFE</span>，这并不安全，但对于例子足以，
        在创建节点时，我们捕获了<span class="highlight">NodeExistsException</span>异常，
        表明Master已经存在，而<span class="highlight">ConnectionLossException</span>异常，
        该异常通常由于网络错误，Server崩溃导致，这时Client并不知道请求是否被Server处理，我们不做处理，
        而是让Client API尝试重新连接。<span class="highlight">InterruptedException</span>
        异常是由客户端线程导致，可交由外部去处理。接着我们通过<span class="highlight">getData()</span>
        来获取节点数据
    </li>
    {% highlight java %}
/**
 * path: 节点路径
 * watch: 是否监听节点数据变化
 * stat: 节点元数据信息
 */
getData(String path, bool watch, Stat stat)
    {% endhighlight %}
    <li>
        我们启动两个进程
    </li>
    {% highlight java %}
public static void main(String[] args) throws Exception {
    String connnectHost = "localhost:2181";
    Master m = new Master(connnectHost);
    m.startZK();
    m.runForMaster();
    if (m.isLeader){
        System.out.println("I am leader");
    } else {
        System.out.println("I am not leader");
    }
    Thread.sleep(600000);
}
    {% endhighlight %}
    <li>
        将看到输出
    </li>
    <img src="{{site.url}}/images/zk/master1.jpg">
    <img src="{{site.url}}/images/zk/master2.jpg">
    <li>
        <h3>异步获取领导权(Mastering)</h3>
    </li>
    <li>
        Zookeeper的API都会有一个<span class="highlight">异步</span>的版本，如创建节点
    </li>
    {% highlight java %}
void create(
    String path,
    byte[] data,
    List<ACL> acl,
    CreateMode createMode,
    AsyncCallback.StringCallback cb, // 回调
    Object ctx //用户定义的上下文，回调时会传入
)
    {% endhighlight %}
    <li>
        该方法会立即返回，只是将Server请求放入队列中，请求过程放在另一个线程中，
        当收到Server响应时，这些响应将在一个专门的回调线程中处理(
        <span class="highlight">因此，你不应该在回调中做太重的操作，或者执行阻塞操作，这会严重影响后续的回调执行</span>)，
        此方法不会抛出异常，任何请求错误将编码为回调的第一个参数，回调形式为
    </li>
    {% highlight java %}
/**
 * rc: 调用结果，OK或者KeeperException异常码
 * path: create传递的path
 * ctx: create传递的context
 * name: 节点名称，若创建成功将等于path(但对于CreateMode.SEQUENTIAL的节点会加上递增整数)
 */
void processResult(int rc, String path, Object ctx, String name)
    {% endhighlight %}
    <li>
        将上面的实现改为异步回调后
    </li>
    {% highlight java %}
private AsyncCallback.StringCallback masterCreateCb = new AsyncCallback.StringCallback() {
    @Override
    public void processResult(int rc, String path, Object ctx, String name) {
        switch (KeeperException.Code.get(rc)){
            case CONNECTIONLOSS:
                checkMaster();
                return;
            case OK: // 创建节点成功，成功获取领导权
                isLeader = true;
                break;
            default:
                isLeader = false;
        }
        System.out.println("I'm " + (isLeader ? "" : "not ") + "the leader");
    }
};

public void runForMaster(){
    zk.create("/master", serverId.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                CreateMode.EPHEMERAL, masterCreateCb, null);
}

private AsyncCallback.DataCallback masterCheckCb = new AsyncCallback.DataCallback() {
    @Override
    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {
        switch(KeeperException.Code.get(rc)) {
            case CONNECTIONLOSS:
                checkMaster();
                return;
            case NONODE: // 没有master节点存在，则尝试获取领导权
                runForMaster();
                return;
            case NODEEXISTS:
                System.out.println("node exists.");
        }
    }
};

private void checkMaster() {
    zk.getData("/master", false, masterCheckCb, null);
}
    {% endhighlight %}
    <li>
        构建元数据
    </li>
    <li>
        <span class="highlight">Master-Worker</span>架构中，我需要初始化一些元数据，如
        <span class="highlight">/workers</span>，
        <span class="highlight">/tasks</span>，
        <span class="highlight">/assign</span>
    </li>
    {% highlight java %}
public void bootstrap() {
    // 存放可用的Worker
    createParent("/workers", new byte[0]);
    // 存放Worker下存放的任务
    createParent("/assign", new byte[0]);
    // 待执行和新提交的任务
    createParent("/tasks", new byte[0]);
    createParent("/status", new byte[0]);
}

private void createParent(String path, byte[] data) {
    zk.create(path,
        data,
        ZooDefs.Ids.OPEN_ACL_UNSAFE,
        CreateMode.PERSISTENT, // 持久节点
        createParentCb,
        data); // 将data传给ctx，这样可以在Callback中继续尝试创建节点
}

private AsyncCallback.StringCallback createParentCb  = new AsyncCallback.StringCallback() {
    @Override
    public void processResult(int rc, String path, Object ctx, String name) {
        switch (KeeperException.Code.get(rc)) {
            case CONNECTIONLOSS:
                createParent(path, (byte[]) ctx); //取出data
                break;
            case OK:
                System.out.println("Parent created");
                break;
            case NODEEXISTS:
                System.out.println("Parent already registered: " + path);
                break;
            default:
                System.err.println("Something went wrong: " + KeeperException.create(KeeperException.Code.get(rc), path));
        }
    }
};
    {% endhighlight %}
    <li>
        <h3>注册工作者(Worker)</h3>
    </li>
    <li>
        接下来我们会在/workers建立起可用的Worker节点，Worker实现
    </li>
    {% highlight java %}
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.util.Random;

/**
* Author: haolin
* On: 3/5/15
*/
public class Worker implements Watcher {

    private static final Logger LOG = LoggerFactory.getLogger(Worker.class);

    private ZooKeeper zk;

    private String connnectHost;

    private Random random = new Random();

    private String serverId = Integer.toHexString(random.nextInt());

    private String status;

    private String name;

    public Worker(String connnectHost) {
        this.connnectHost = connnectHost;
    }

    public void startZK() throws IOException {
        zk = new ZooKeeper(connnectHost, 15000, this);
    }

    @Override
    public void process(WatchedEvent event) {
        LOG.info(event.toString() + ", " + connnectHost);
    }

    /**
    * 注册自己为Worker
    */
    public void register() {
        name = "worker-" + serverId;
        zk.create(
            "/workers/worker-" + name, // worker标识
            "Idle".getBytes(), //状态空闲
            ZooDefs.Ids.OPEN_ACL_UNSAFE,
            CreateMode.EPHEMERAL, //临时节点
            createWorkerCallback,
            null
        );
    }

    private AsyncCallback.StringCallback createWorkerCallback = new AsyncCallback.StringCallback() {
        public void processResult(int rc, String path, Object ctx, String name) {
            switch (KeeperException.Code.get(rc)) {
                case CONNECTIONLOSS:
                    register();
                    break;
                case OK:
                    LOG.info("Registered successfully: " + serverId);
                    break;
                case NODEEXISTS:
                    LOG.warn("Already registered: " + serverId);
                    break;
                default:
                    LOG.error("Something went wrong: "
                        + KeeperException.create(KeeperException.Code.get(rc), path));
            }

        }
    };

    private AsyncCallback.StatCallback statusUpdateCallback = new AsyncCallback.StatCallback() {
        public void processResult(int rc, String path, Object ctx, Stat stat) {
            switch(KeeperException.Code.get(rc)) {
                case CONNECTIONLOSS:
                    updateStatus((String)ctx);
                    return;
            }
        }
    };

    synchronized private void updateStatus(String status) {
        if (status == this.status) {
            zk.setData(
                "/workers/" + name,
                status.getBytes(),
                -1, // -1将不会检查版本
                statusUpdateCallback,
                status
            );
        }
    }

    /**
    * 设置状态
    * @param status 新状态
    */
    public void setStatus(String status) {
        this.status = status;
        updateStatus(status);
    }

    public static void main(String args[]) throws Exception {
        Worker w = new Worker("localhost:2181");
        w.startZK();
        w.register();
        Thread.sleep(60000);
    }
}
    {% endhighlight %}
    <li>
        为了保证状态更新的最终一致性，上面Worker实现中需要着重注意的是<span class="highlight">updateStatus()</span>方法，需要使用
        <span class="highlight">synchronized</span>
        和<span class="highlight">status == this.status</span>判断，否则会出现本地和服务器状态不一致的情况，
        比如下面的场景
    </li>
    <p class="wrap">
        1. <span class="highlight">Worker</span>开始执行任务task-1，因此调用
        <span class="highlight">setStatus("working")</span>(即this.status = "working")。 <br />
        2. Client API发起<span class="highlight">setData()</span>调用，但是此时发生网络错误。 <br />
        3. 于是Client API认为与Server失去连接，但在调用<span class="highlight">statusUpdateCallback</span>回调之前，
            <span class="highlight">Worker</span>完成了任务，变得空闲。<br />
        4. 因此调用<span class="highlight">setStatus("idle")</span>(即this.status = "idle")。<br />
        5. 然而，现在Client开始处理第二步中产生的网络错误回调<span class="highlight">statusUpdateCallback</span>，
           若不判断<span class="highlight">status == this.status</span>，<span class="highlight">Worker</span>的状态将被设置为
        <span class="highlight">"working"</span>，这就会造成Client和Server状态不一致。
    </p>
    <li>
        似乎觉得将<span class="highlight">synchronized</span>放到<span class="highlight">setStatus()</span>前更合理一些，
        会不会出现<span class="highlight">setStatus("working")</span>后，执行第一条<span class="highlight">this.status = status</span>之前，
        CPU时间片切换，<span class="highlight">Worker</span>就完成了任务，并<span class="highlight">setStatus("idle")</span>，即
        <span class="highlight">setData("idle")</span>调用在<span class="highlight">setData("working")</span>之前。
    </li>
    <li>
        <h3>任务排队</h3>
    </li>
    <li>
        最后的组件则是<span class="highlight">Client</span>，
        我们将把任务创建在<span class="highlight">/tasks</span>节点下，
        并且为每个任务分配唯一的序号。
    </li>
    {% highlight java %}
public class Client implements Watcher {

    private ZooKeeper zk;

    private String connnectHost;

    public Client(String connnectHost) { this.connnectHost = connnectHost; }

    public void startZK() throws Exception {
        zk = new ZooKeeper(connnectHost, 15000, this);
    }

    public String queueCommand(String command) throws Exception {
        String name = null;
        while (true) {
            try {
                // 新节点名称
                name = zk.create("/tasks/task-",
                command.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT_SEQUENTIAL); // 持久临时节点
                return name;
            } catch (KeeperException.NodeExistsException e) {
                throw new Exception(name + " already appears to be running");
            } catch (KeeperException.ConnectionLossException e) {
            }
        }
    }

    @Override
    public void process(WatchedEvent event) {

    }

    public static void main(String args[]) throws Exception {
        Client c = new Client("localhost:2181");
        c.startZK();
        String name = c.queueCommand("some cmd");
        System.out.println("Created " + name);
    }
}
    {% endhighlight %}
    <li>
        创建任务节点时，如果创建失败，我们就尝试重新创建，但当有多个应用都在创建该任务时，
        有可能同一个任务会被创建多次，若要控制某个任务最多创建一次，可以为任务分配唯一的ID。
    </li>
    <li>
        <h3>管理员Client</h3>
    </li>
    <li>
        我们还需要一个管理员Client来查看系统的状态，通常使用<span class="highlight">getData()</span>和<span class="highlight">getChildren()</span>方法。
    </li>
    {% highlight java %}
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;
import java.util.Date;

/**
* Author: haolin
* On: 3/9/15
*/
public class AdminClient implements Watcher {

    private ZooKeeper zk;

    private String connnectHost;

    public AdminClient(String connnectHost) { this.connnectHost = connnectHost; }

    public void start() throws Exception {
    zk = new ZooKeeper(connnectHost, 15000, this);
    }

    public void listState() throws KeeperException, InterruptedException {
    try {
        Stat stat = new Stat();
            // master状态
            byte masterData[] = zk.getData("/master", false, stat);
            Date startDate = new Date(stat.getCtime()); //master创建时间
            System.out.println("Master: " + new String(masterData) + " since " + startDate);
        } catch (KeeperException.NoNodeException e) {
            System.out.println("No Master");
        }
        // worker状态
        System.out.println("Workers:");
        for (String w: zk.getChildren("/workers", false)) {
        byte data[] = zk.getData("/workers/" + w, false, null);
        String state = new String(data);
            System.out.println("\t" + w + ": " + state);
        }
        // 任务分配状态
        System.out.println("Tasks:");
        for (String t: zk.getChildren("/assign", false)) {
            System.out.println("\t" + t);
        }
    }

    @Override
    public void process(WatchedEvent event) {

    }

    public static void main(String args[]) throws Exception {
        AdminClient c = new AdminClient("localhost:2181");
        c.start();
        c.listState();
    }
}
    {% endhighlight %}
    <li>
        <h2>处理状态变化</h2>
    </li>
    <li>
        应用需要关注Zookeeper的状态变化，这并不少见，比如
        <span class="highlight">Master-Worker</span>架构中，
        <span class="highlight">备份master</span>需要知道<span class="highlight">主master</span>是否崩溃，
        <span class="highlight">Workers</span>需要知道是否有新的任务分配给自己，在Zookeeper中，
        可以通过<span class="highlight">Watcher</span>机制来实现状态变化监听。
    </li>
    <li>
        <h3>一次性触发</h3>
    </li>
    <li>
        <span class="highlight">Watches</span>是连接
        <span class="highlight">Znode</span>和<span class="highlight">事件类型</span>
        (Znode数据变化，或节点被删除)的一种<span class="highlight">一次性触发器</span>。
        <span class="highlight">Watches</span>是同Client的连接会话想关联的，一旦会话过期了，
        该会话创建的<span class="highlight">Watches</span>将被移除。
        <span class="highlight">Watches</span>可以在多个Server之前跨连接，
        比如，当Client与集群中的一个Server断开，然后重连到另一个Server，Client将发送未处理的<span class="highlight">Watches</span>
        到该Server，当注册一个<span class="highlight">Watch</span>时，该Server会检查该<span class="highlight">Watch</span>
        监听的节点是否发生变化，如发生变化，将通知该Client，否则Client就将该<span class="highlight">Watch</span>注册到新的Server上。
    </li>
    <li>
        <h3>一次性触发器会丢失事件吗?</h3>
    </li>
    <li>
        答案是<span class="highlight">肯定的</span>。然而，这种问题值得讨论。
        但对于在<span class="highlight">收到通知</span>
        和<span class="highlight">注册新的Watch</span>
        之间丢失事件，我们都可以通过主动读取Zookeeper状态来解决。
        比如，<span class="highlight">Worker</span>收到有新的任务分配通知后，
        可以通过<span class="highlight">getChildren()</span>获取所有分配的任务(即使在收到通知后，又有新任务分配)，
        再对任务分配节点进行<span class="highlight">Watch</span>。
    </li>
    <li>
        <h3>如何设置Watches</h3>
    </li>
</ul>






